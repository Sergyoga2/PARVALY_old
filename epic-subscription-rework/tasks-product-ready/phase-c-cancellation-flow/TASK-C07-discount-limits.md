# TASK-C07: Лимит retention-скидок

## Meta

| Поле | Значение |
|------|----------|
| ID | TASK-C07 |
| Title | Механизм лимитирования retention-скидок (cancellation + win-back) |
| Phase | C — Cancellation Flow |
| Priority | P1 |

---

## A) Краткое описание

Реализовать механизм ограничения частоты предоставления retention-скидок: не более 1 скидки за 6 месяцев на одного пользователя. Лимит является общим (shared) для двух контекстов: удерживающая скидка при отмене подписки (C03) и win-back-предложение для возврата ушедших пользователей (D03/D04).

Механизм должен предоставлять возможность проверки доступности скидки (eligible / not eligible) и фиксировать факт использования скидки. Используется задачами C03 (save-offer скидка) и D03/D04 (win-back) для определения, показывать ли пользователю скидочное предложение.

---

## B) Scope / Out of Scope

### Scope
- Хранение даты последнего использования retention-скидки для каждого пользователя
- Проверка доступности скидки: прошло ли 6 месяцев с последнего использования
- Фиксация факта использования скидки (обновление даты)
- Единый механизм для cancellation save-offer (C03) и win-back (D03/D04)
- Обработка edge cases: первое использование, граничные даты

### Out of Scope
- UI предложения скидки (C03)
- Логика применения скидки к подписке (C03)
- Win-back флоу (D03/D04)
- Размер скидки и её параметры (определяются в C03 / D03)
- Промокоды и другие типы скидок (не retention)

---

## C) Бизнес-правила и состояния

### Основное правило
- 1 retention-скидка за 6 месяцев на пользователя
- Лимит общий: использование скидки в одном контексте (cancellation) блокирует использование в другом (win-back) и наоборот

### Проверка доступности

| Условие | Результат |
|---------|-----------|
| Скидка никогда не использовалась | Доступна |
| Последнее использование > 6 месяцев назад | Доступна |
| Последнее использование ≤ 6 месяцев назад | Недоступна |

### Данные пользователя
- Для каждого пользователя хранится: дата последнего использования retention-скидки
- При первом использовании: дата инициализируется
- При повторном использовании: дата обновляется

### Логика расчёта 6 месяцев
- «6 месяцев» = 180 дней (или календарных 6 месяцев — open question)
- Отсчёт от даты фактического применения скидки (не от даты показа предложения)

### Потребители механизма

| Задача | Контекст использования |
|--------|----------------------|
| C03 | Проверка перед показом скидки при отмене |
| D03 | Проверка перед показом win-back скидки (email) |
| D04 | Проверка перед показом win-back скидки (in-app) |

### Взаимодействие между контекстами

Пример:
1. Пользователь получил скидку при отмене (C03) 1 марта
2. Пользователь отменил подписку 15 апреля
3. Win-back (D03) пытается предложить скидку 1 мая → **недоступна** (прошло 2 месяца)
4. Win-back (D03) пытается предложить скидку 1 октября → **доступна** (прошло > 6 месяцев)

---

## D) Пользовательские и системные сценарии

1. **Given** пользователь никогда не получал retention-скидку, **When** запрашивается проверка доступности, **Then** ответ: «доступна».

2. **Given** пользователь получил скидку 3 месяца назад, **When** запрашивается проверка, **Then** ответ: «недоступна», с указанием даты, когда станет доступна.

3. **Given** пользователь получил скидку 7 месяцев назад, **When** запрашивается проверка, **Then** ответ: «доступна».

4. **Given** пользователь получил скидку ровно 6 месяцев назад (граничный случай), **When** запрашивается проверка, **Then** ответ: «доступна» (≥ 6 месяцев).

5. **Given** пользователь получил скидку через win-back (D03) 2 месяца назад, **When** C03 запрашивает проверку, **Then** ответ: «недоступна» (общий лимит).

6. **Given** пользователь принял скидку при отмене (C03), **When** скидка применена, **Then** дата последнего использования обновляется.

7. **Given** пользователю показали скидку, но он отказался, **When** проверяется лимит, **Then** дата НЕ обновляется (обновление только при принятии).

8. **Given** два запроса на использование скидки одновременно (race condition), **When** обрабатываются, **Then** только один проходит успешно (конкурентная безопасность).

9. **Given** ошибка при фиксации использования скидки, **When** скидка уже применена к подписке, **Then** ситуация логируется для ручного разбора (предотвращение рассогласования).

10. **Given** пользователь с удалённым аккаунтом, **When** аккаунт восстановлен, **Then** данные о лимите скидок сохранены (не сбрасываются).

11. **Given** системе нужно массово проверить доступность скидок (для рассылки win-back), **When** выполняется проверка для списка пользователей, **Then** проверка выполняется эффективно (не по одному).

12. **Given** параметр «6 месяцев» нужно изменить, **When** бизнес решает сменить период, **Then** изменение не требует доработки кода (настраиваемый параметр).

---

## E) Acceptance Criteria

- [ ] Для каждого пользователя хранится дата последнего использования retention-скидки
- [ ] Проверка доступности корректно возвращает результат: доступна / недоступна
- [ ] При недоступности возвращается дата, когда скидка станет доступна
- [ ] Лимит является общим для cancellation (C03) и win-back (D03/D04)
- [ ] Дата обновляется только при фактическом принятии скидки, не при показе
- [ ] Граничный случай (ровно 6 месяцев) обрабатывается корректно
- [ ] Конкурентные запросы обрабатываются безопасно (нет двойного использования)
- [ ] Период лимита (6 месяцев) является настраиваемым параметром
- [ ] Механизм поддерживает массовую проверку (для win-back рассылок)
- [ ] Ошибки фиксации логируются для ручного разбора

---

## F) Аналитика/события

| Событие | Обязательные свойства |
|---------|----------------------|
| `discount_eligibility_checked` | user_id, is_eligible, last_discount_date (nullable), context (cancellation / winback) |
| `discount_used` | user_id, subscription_id, context (cancellation / winback), discount_percent |
| `discount_limit_hit` | user_id, context (cancellation / winback), last_discount_date, next_eligible_date |

---

## G) Риски и допущения (Assumptions)

### Допущения
- Retention-скидка — это единственный тип скидки, подпадающий под данный лимит (промокоды и маркетинговые скидки не учитываются)
- Лимит 1 раз в 6 месяцев — финальный, согласован с продуктом
- Дата использования привязана к пользователю, а не к подписке (при повторной подписке лимит сохраняется)

### Риски
- Рассогласование: скидка применена к подписке, но дата лимита не обновилась (или наоборот) → необходимо обеспечить атомарность или компенсацию
- При миграции данных (если ранее были скидки без трекинга) — лимит может некорректно работать для существующих пользователей
- Общий лимит для cancellation и win-back может ухудшить retention: пользователь, использовавший cancellation-скидку, не получит win-back-скидку в течение 6 месяцев

---

## H) Open questions для CTO/разработчиков

1. «6 месяцев» — это ровно 180 дней или календарных 6 месяцев (с учётом разной длины месяцев)?
2. Где хранить дату последнего использования скидки: в основном хранилище данных пользователя или в отдельном модуле?
3. Нужно ли хранить историю всех использований скидок (для аналитики), или достаточно только последней даты?
4. Как обеспечить атомарность: проверка доступности + применение скидки + обновление даты должны быть транзакционными?
5. Как обрабатывать ситуацию, когда скидка применена, но пользователь вернул деньги (refund) — сбрасывается ли лимит?
6. Нужна ли возможность для администратора сбросить лимит вручную (для поддержки)?
7. Как обеспечить производительность при массовой проверке (для win-back рассылки на тысячи пользователей)?
8. Нужно ли учитывать скидки, выданные до внедрения данного механизма (миграция данных)?
9. Если пользователь имеет несколько подписок (в будущем), лимит на пользователя или на подписку?
10. Нужно ли логировать все проверки доступности (для аудита) или только факты использования?
11. Как обрабатывать timezone при расчёте 6 месяцев: UTC или timezone пользователя?
12. Нужен ли механизм «сухого прогона» (dry run) для проверки доступности без фиксации?
13. При изменении периода лимита (с 6 на 3 месяца) — применяется ли новый период ретроактивно?
14. Нужно ли уведомлять пользователя, когда скидка снова станет доступна?
15. Должна ли проверка доступности кешироваться (для снижения нагрузки) или выполняться каждый раз заново?

---

## I) Что убрано из исходника

- **Конкретное поле пользователя** (`last_discount_used_at`) → заменено на «дата последнего использования retention-скидки»
- **Конкретный API endpoint** → заменён на «механизм проверки доступности»
- **Детали хранения данных** (SQL, конкретная таблица) → заменены на «хранилище данных»
- **Конкретные технологии** → заменены на нейтральные термины («атомарность», «конкурентная безопасность»)
