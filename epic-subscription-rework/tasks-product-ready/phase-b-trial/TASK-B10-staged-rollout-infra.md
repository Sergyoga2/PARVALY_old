# TASK-B10: Инфраструктура поэтапного раскатывания trial

## Meta

| Поле | Значение |
|------|----------|
| ID | TASK-B10 |
| Title | Feature flag с процентным раскатыванием для trial |
| Phase | B — Trial |
| Priority | P1 |

---

## A) Краткое описание

Обеспечить возможность постепенного включения trial для контроля рисков: 20% → 50% → 100% пользователей. Один и тот же пользователь должен всегда видеть одинаковый вариант (consistent). Изменение процента должно быть возможно без деплоя.

---

## B) Scope / Out of Scope

### Scope
- Feature flag `trial_enabled` с процентным rollout (0–100%)
- Consistent distribution: один и тот же пользователь всегда видит одинаковый вариант
- Для неавторизованных: consistent distribution по идентификатору сессии/cookie
- Возможность изменения процента без деплоя (admin UI или конфигурация)

### Out of Scope
- A/B testing framework
- Статистическая значимость

---

## C) Бизнес-правила и состояния

### Логика раскатывания
- При 0%: trial CTA не видно никому
- При 100%: trial CTA видно всем eligible пользователям
- При N%: ~N% пользователей видят trial CTA
- Один пользователь при обновлении страницы всегда видит одинаковый вариант
- Смена процента вступает в силу для НОВЫХ пользователей; пользователи, уже получившие trial, не затрагиваются

### План раскатывания
- Этап 1: 20% → мониторинг 3-5 дней
- Этап 2: 50% → мониторинг 3-5 дней
- Этап 3: 100%

---

## D) Пользовательские и системные сценарии

1. **Given** flag trial_enabled=20%, **When** 1000 пользователей, **Then** ~200 видят trial CTA.
2. **Given** один пользователь, **When** обновляет страницу, **Then** всегда видит одинаковый вариант.
3. **Given** flag trial_enabled=0%, **When** любой пользователь, **Then** trial CTA не видно.
4. **Given** flag trial_enabled=100%, **When** eligible пользователь, **Then** trial CTA видно.
5. **Given** неавторизованный пользователь, **When** trial_enabled=50%, **Then** consistent результат по сессии.
6. **Given** admin меняет процент с 20% на 50%, **When** без деплоя, **Then** изменение вступает в силу.
7. **Given** пользователь уже активировал trial (при 20%), **When** процент меняется на 0%, **Then** active trial не затрагивается.
8. **Given** 10 000 случайных пользователей, trial_enabled=50%, **When** проверяем распределение, **Then** ~50% с допустимым отклонением.

---

## E) Acceptance Criteria

- [ ] При 0% — никто не видит trial CTA
- [ ] При 100% — все eligible видят trial CTA
- [ ] Один пользователь всегда видит одинаковый вариант (consistent)
- [ ] Процент можно изменить без деплоя
- [ ] Распределение ~равномерное на большой выборке
- [ ] Неавторизованные пользователи получают consistent результат

---

## F) Аналитика/события

Нет дополнительных событий (feature flag variant включается в существующие события через user property или параметр).

---

## G) Риски и допущения (Assumptions)

### Допущения
- Инфраструктура feature flags может быть реализована различными способами (выбор за CTO)
- Consistent hashing обеспечит равномерное распределение

### Риски
- Неравномерное распределение hash-функции → тестировать на большой выборке
- Изменение процента требует деплой (если через env var) → предусмотреть runtime-изменение

---

## H) Open questions для CTO/разработчиков

1. Есть ли существующая инфраструктура feature flags в проекте?
2. Если нет: реализовать самим (в хранилище данных) или использовать внешний сервис?
3. Как обеспечить consistent hashing для неавторизованных пользователей?
4. Нужен ли admin UI для управления процентом или достаточно конфигурации?
5. Как передавать значение flag на frontend: через API, серверный рендер, или cookie?
6. Нужно ли логировать, какой пользователь попал в какую группу?
7. Как обрабатывать ситуацию, когда пользователь был неавторизован (group A) → зарегистрировался (group B)?
8. Нужна ли возможность принудительно включить/выключить для конкретного пользователя (override)?
9. Как тестировать распределение: автоматический тест или ручная проверка?
10. Нужна ли поддержка нескольких feature flags одновременно (для будущих функций)?

---

## I) Что убрано из исходника

- **Ruby-код** (`FeatureFlag`, `FeatureFlagService`, `Digest::MD5.hexdigest`) → заменён на описание бизнес-логики
- **Конкретная реализация** (DB-based vs внешний сервис) → вынесена в Open Questions
- **SQL-модель FeatureFlag** → убрана
- **Test Cases** → трансформированы в Acceptance Criteria
